package array;

public class ExClass {
/*
 *  1. 클래스
 *     클래스는 하나의 프로그램이다.
 *     좀 더 자세히 말하면 하나의 프로그램 설계도이다.
 *     객체지향프로그래밍, 3세대 언어에서는 
 *     하나의 커다란 프로그램이 작은 프로그램들을 활용해서 
 *     필요한 코드의 양을 줄이자가 바로 3세대 언어, 객체지향언어가 목표하는 바이다.
 *     
 *  2. 객체
 *     객체란 클래스 변수를 뜻한다.
 *     즉 객체지향 프로그래밍이란, 클래스 변수를 사용해서 그 변수가 생성하는 내부 메시지를 활용해서
 *     우리가 필요한 프로그램을 만드는것을 객체지향 프로그래밍이라고 한다.
 *     클래스라는 것 자체가 한가지 책임에 따라 거기에 알맞는 정보를 넣는 칸과, 그리고 기능들이 구현되어
 *     있기 때문에 우리가 필요한 클래스 변수, 즉 객체를 만들어서 우리 프로그램에서 사용하게 되는것이다.
 *  
 *  3. 클래스의 구성요소
 *     클래스는 필드와 메소드로 이루어져있다.
 *     필드: 해당 클래스의 객체가 가질 수 있는 데이터를 규정 (=구조체)
 *     메소드: 해당 클래스의 객체가 공통적으로 가지고 있는 기능들
 *     즉 클래스는 정보를 담을 공간과 그리고 기능이 적혀져있다.
 *     그리고 해당 클래스 객체가 어떤 정보를 담을지는 우리가 객체를 만들면서 설정하게 된다.
 *     객체는 똑같은 클래스의 객체라면 기능은 모두 같다!
 *     하지만, 그 객체에 필드의 값이 달라질 수 있고 그것에 따라서 같은 객체, 다른 객체 구분이 가능하다!
 *     
 *  4. 필드
 *     필드란 해당 객체가 내부적으로 가지고 있는 데이터를 할당할 공간을 뜻한다.
 *     변수처럼
 *     데이터타입 필드이름
 *     으로 선언한다.
 *     실제 어떤 데이터가 들어갈지는 해당 객체를 사용할때 우리가 지정해주면 된다!
 *     
 *  5. 메소드
 *     메소드란 해당 클래스의 모든 객체들이 공통적으로 가지고 있는 기능을
 *     메소드라고 한다.
 *     필드와는 다르게 모든 메소드들은 똑같은 로직으로 돌아간다.
 *     예를 들어, 학생의 국영수 점수를 합쳐서 총점을 계산하는 메소드는
 *     A 학생이건, B 학생이건 똑같다.
 *     
 *  6. 생성자 (Constructor)
 *     생성자란, 해당 클래스 변수가 초기화 될때 
 *     호출되는 메소드이다.
 *     우리가 아무런 생성자를 안 만들어주면
 *     자바에서 기본적으로 제공해주는 생성자가
 *     해당 클래스의 필드를 초기화해준다.
 *     만약 해당 필드의 데이터타입이 참조형이면
 *     null 로 초기화하고
 *     기본형 데이터타입이면 0으로 초기화한다!
 *     
 *     만약 사용자가 생성자를 따로 만들어준다면
 *     기본생성자가 호출되서
 *     클래스의 필드를 null과 0으로 초기화 하고
 *     사용자의 생성자가 호출되서 추가적인 작업을 해주게 된다!
 *           
 *     생성자는 메소드이지만 특수하게
 *     return 타입이 존재하지 않는 형태이다
 *     즉 
 *     public 클래스이름() {
 *     
 *     }
 *     으로 선언하게 된다!
 *     
 *     다른 메소드의 오버로딩처럼 파라미터에 따라서
 *     호출되는 생성자도 달라진다!
 *     
 *     마지막으로 만약 사용자가 파라미터가 있는 생성자만 선언과 구현한다면
 *     더이상 파라미터 없는 생성자는 사용할 수 없다.
 *     따라서, 파라미터 있는 생성자와 파라미터 없는 생성자 모두다 필요하다면
 *     둘다 만들어야 한다!
 *     만약 해당 객체가 외부로부터 어떠한 값을 반드시 받아와야한다면
 *     파라미터있는 생성자만 만들어서 외부의 값을 강제할 수도 있다!
 *     
 *  7. 필드와 파라미터의 호출 우선도
 *     필드의 경우, 해당 클래스에서는 어디서든 "접근 가능하다"
 *     하지만 파라미터 혹은 메소드 안의 변수가 
 *     필드와 똑같은 이름일 수 있는데
 *     이때는 무조건 파라미터 혹은 변수가 지칭된다.
 *     따라서 파라미터 혹은 변수와 필드가 똑같은 이름일 경우
 *     필드 앞에는 항상
 *     this. 을 붙여서
 *     해당 메소드를 실행하는 "객체의" 라고 의미를 명확하게 해주어야 한다!   
 *     
 *  8. null
 *     널이란, 참조형 변수들한테서 발생하는 특수한 상태이다.
 *     스택 영역에 해당 변수 공간이 마련되고 주소값이 부여되었지만
 *     힙 영역에 해당 주소에는 아무것도 없는 상태를 널 이라고 한다.
 *     널인 상태에서는 해당 객체의 필드나 메소드 혹은 배열의 요소에 접근할 수 없다!
 *     만약 널인 상태의 참조형 변수의 메소드나 요소, 필드를 접근할려고 한다면
 *     NullPointerException이 발생하게 된다!
 *     
 *     예를 들어서 
 *     String string = ""; 과
 *     String string = null 은 다른 의미이다.
 *     A. String string = "";
 *        이 코드는 String 클래스 객체 string이 있고, 아무런 문자도 안들어가있지만
 *        그외에 메소드나 공간은 확보가 되어있는 상태이다! 즉 NullPointerException은
 *        발생하지 않는다.
 *     B. String string = null;
 *        이 코드에서는 String 클래스 객체 string이 선언 되었고 heap 영역의 메모리주소값까지는
 *        부여가 되었지만, 실제 해당하는 heap 영역의 메모리는 아직 초기화가 안되어서 String 클래스에
 *        관한 내용이 하나도 없는 상태이다.
 *  
 *  9. java.lang.Object
 *     Object 클래스는 자바가 기본적으로 제공해주는 클래스인데 
 *     자바가 기본적으로 제공하던 아니면 누군가가 만들었던 뭐든간에 자바의 존재하는 모든 클래스는
 *     java.lang.Object를 상속 받는다.
 *     상속이란, 부모 클래스의 메소드, 필드를 자식 클래스가 다시 안써주어도 그대로 받아서 쓸 수 있게
 *     "코드를 물려주는" 것이다.
 *     java.lang.Object는 내부적으로
 *     기본 생성자, toString(), equals() 등의 다양한 메소드를 선언과 구현해서 자식 클래스가
 *     또다시 선언과 정의를 하지 않아도 쓸 수 있게 만들어놓았다. 
 *     하지만 이 Object 클래스가 상속해주는 메소드는 매우 애매모호하게 구현해놓았기 때문에
 *     자식 클래스가 해당 메소드들을 사용하면, 부정확한 값을 얻을 가능성이 매우 높다.
 *     따라서, 만약 여러분들이 구현하는 클래스가 toString(), equals() 등의 메소드가 필요하다면
 *     여러분들이 반드시
 *     해당 메소드들을 '재정의' 해주어야 여러분들이 원하는 결과를 얻을 수 있다.
 *     
 *     이렇게 자식클래스가 부모클래스의 메소드를 '재정의' 하는 것을 override 라고 한다!
 *     만약 자식 클래스가 부모 클래스의 메소드를 오버라이드할 때에는 
 *     부모 클래스가 해당 메소드를 선언한 방법 그대로 똑같이 적어주어야만 한다!
 *     만약 파라미터의 이름을 제외한 나머지 중 하나라도 틀리면 오버라이드가 되지 않는다!
 *     
 *     A. toString()
 *        toString()의 경우 해당 객체의 정보를 String으로 바꿔서 return한다.
 *        java.lang.Object에서는
 *        public String toString() 으로 선언하였고 그 내용은 해당 객체의 정보 중
 *          "패키지.클래스이름@메모리주소" 가 출력되도록 구현해놓았다.
 *        만약 우리가 해당 클래스의 정보 중 위의 정보가 아닌 필드의 값과 관련한 정보를
 *        String으로 뽑아내야한다면 당연히 toString() 메소드를 오버라이드 해야한다!
 *     B. equals()
 *        equals()의 경우 두 객체의 주소 값이 아닌 필드에 저장된 값을 기준으로 해서
 *        두 객체가 같은지 아닌지를 비교한다.
 *        하지만... java.lang.Object의 equals() 메소드는
 *                      return a == b; 
 *        즉 주소값 비교의 결과값을 return 하도록 구현되어있다.
 *        만약 여러분들이 두 객체의 비교를 해야할 일이 있다면(=데이터담당 클래스일 경우)
 *        반드시 equals를 오버라이드 해야한다.
 *        java.lang.Object의 equals 메소드는 다음과 같이 되어있다.
 *        
 *        public boolean equals(Object o){
 *            return this == o;
 *        }
 *  
 *  10. 클래스의 캡슐화와 getter/setter
 *      캡슐화란, 클래스의 모든 필드 그리고 외부가 꼭 알아야 하는 몇몇 메소드를 제외하고서는
 *      모두다 private 접근제한자를 적용시켜서 외부에서는 이 클래스 객체안의 내용을 알 수 없게 만드는
 *      데이터 은닉화의 방법이다.
 *      데이터 은닉화를 하는 방법은 외부가 이 클래스 객체의 필드를 직접 접근해서 값을 저장하거나
 *      불러올 수 없고 꼭 메소드를 이용해서 간접적으로 접근하게 만들기 위함이다.
 *      private으로 설정된 필드에 값을 저장할 때에는 
 *      setter 라는 메소드를 이용하여 값을 저장하고
 *      필드에 저장된 값을 호출할 때에는
 *      getter 라는 메소드를 통하여 값을 호출한다.
 *      
 *      setter 메소드는 다음과 같은 양식을 가진다.
 *      public void set필드이름(필드타입 필드이름){
 *          this.필드이름 = 필드이름;
 *      }
 *      
 *      getter 메소드는 다음과 같은 양식을 가진다.
 *      public 필드타입 get필드이름(){
 *          return 필드이름;
 *      }
 */
}












